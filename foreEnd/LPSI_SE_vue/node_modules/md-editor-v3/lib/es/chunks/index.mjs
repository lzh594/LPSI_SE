import { inject as P, onMounted as S, watch as C, toRef as Y, nextTick as O, shallowRef as R, ref as U, computed as H, defineComponent as ee, createVNode as A, Fragment as de, reactive as te, provide as F, onBeforeUnmount as me } from "vue";
import { e as I, p, m as fe, k as j, f as G, h as pe, s as D, a as he, i as ge, g as V, j as z, l as ye, b as ve, d as be } from "./config.mjs";
import { u as we, a as ke, b as g, P as $e, C as W, B as M, O as ne, E as Ce, U as Ie, c as oe, d as K, F as q, e as Z, H as J, f as X, R as re, h as Se, T as Ee } from "./index4.mjs";
import { a as _, u as Pe } from "./dom.mjs";
import Te from "medium-zoom";
import { debounce as ae } from "@vavt/util";
import _e from "copy-to-clipboard";
import Fe from "markdown-it";
import He from "markdown-it-image-figures";
import xe from "markdown-it-task-lists";
import Ae from "lru-cache";
const Me = (e, a) => {
  const l = P("editorId"), { noImgZoomIn: t } = e, n = ae(() => {
    const r = document.querySelectorAll(`#${l}-preview img`);
    r.length !== 0 && Te(r, {
      background: "#00000073"
    });
  });
  S(() => {
    !t && n();
  }), C([a, Y(e.setting, "preview")], () => {
    !t && n();
  });
}, Re = Me, Be = (e, a) => {
  if (typeof a[e] == "string")
    return a[e];
  const l = `<i class="${p}-iconfont ${p}-icon-${e}"></i>`;
  switch (I.iconfontType) {
    case "svg":
      return `<svg class="${p}-icon" aria-hidden="true"><use xlink:href="#${p}-icon-${e}"></use></svg>`;
    default:
      return l;
  }
}, Le = (e, a) => {
  const l = P("editorId"), t = P("usedLanguageText"), n = P("customIcon"), r = () => {
    document.querySelectorAll(`#${l}-preview pre`).forEach((u) => {
      var b, y;
      let s = -1;
      (b = u.querySelector(".copy-button")) == null || b.remove();
      const o = ((y = t.value.copyCode) == null ? void 0 : y.text) || "复制代码", d = document.createElement("span");
      d.setAttribute("class", "copy-button"), d.dataset.tips = o, d.innerHTML = Be("copy", n.value), d.addEventListener("click", () => {
        var v, k;
        clearTimeout(s);
        const m = u.querySelector("code").innerText, h = _e(e.formatCopiedText(m)), f = ((v = t.value.copyCode) == null ? void 0 : v.successTips) || "已复制！", w = ((k = t.value.copyCode) == null ? void 0 : k.failTips) || "已复制！";
        d.dataset.tips = h ? f : w, s = window.setTimeout(() => {
          d.dataset.tips = o;
        }, 1500);
      }), u.appendChild(d);
    });
  }, i = () => {
    O(r);
  }, c = (u) => {
    u && O(r);
  };
  C(() => a.value, i), C(() => e.setting.preview, c), C(() => e.setting.htmlPreview, c), C(() => t.value, r), S(r);
}, Ne = Le, Oe = (e) => {
  var r;
  const a = (r = I.editorExtensions) == null ? void 0 : r.highlight, l = a == null ? void 0 : a.instance, t = P("highlight"), n = R(l);
  return S(() => {
    if (!e.noHighlight && !n.value) {
      const i = document.createElement("script");
      i.src = t.value.js, i.onload = () => {
        n.value = window.hljs;
      }, i.id = `${p}-hljs`, _(i, "hljs");
      const c = document.createElement("link");
      c.rel = "stylesheet", c.href = t.value.css, c.id = `${p}-hlCss`, _(c);
    }
  }), C(
    () => t.value.css,
    (i) => {
      Pe(`${p}-hlCss`, "href", i);
    }
  ), n;
}, Ue = Oe, je = (e) => {
  const a = P("theme"), { editorExtensions: l } = I, t = l == null ? void 0 : l.mermaid, n = R(t == null ? void 0 : t.instance), r = R(-1), i = new Ae({
    max: 1e3,
    // 缓存10分钟
    ttl: 6e5
  }), c = () => {
    const s = n.value;
    !e.noMermaid && s && (s.initialize({
      startOnLoad: !1,
      theme: a.value === "dark" ? "dark" : "default"
    }), r.value = r.value + 1);
  };
  return C(
    () => a.value,
    () => {
      i.clear(), c();
    }
  ), S(() => {
    if (!e.noMermaid && !(t != null && t.instance)) {
      const s = (t == null ? void 0 : t.js) || fe;
      if (/\.mjs/.test(s))
        import(
          /* @vite-ignore */
          /* webpackIgnore: true */
          s
        ).then((o) => {
          n.value = o.default, c();
        });
      else {
        const o = document.createElement("script");
        o.id = `${p}-mermaid`, o.src = s, o.onload = () => {
          n.value = window.mermaid, c();
        }, _(o, "mermaid");
      }
    }
  }), { mermaidRef: n, reRenderRef: r, replaceMermaid: () => {
    O(() => {
      if (!e.noMermaid && n.value) {
        const s = document.querySelectorAll(
          `div.${p}-mermaid`
        ), o = document.createElement("div");
        o.style.width = document.body.offsetWidth + "px", o.style.height = document.body.offsetHeight + "px", o.style.position = "fixed", o.style.zIndex = "-10000", o.style.top = "-10000";
        let d = s.length;
        d > 0 && document.body.appendChild(o), s.forEach(async (b) => {
          let y = i.get(b.innerText);
          if (!y) {
            const h = we(), f = n.value.renderAsync || n.value.render;
            let w = "";
            try {
              w = await f(h, b.innerText, o);
            } catch {
            }
            y = typeof w == "string" ? w : w.svg, i.set(b.innerText, y);
          }
          const m = document.createElement("p");
          m.className = `${p}-mermaid`, m.setAttribute("data-processed", ""), m.innerHTML = y, b.dataset.line !== void 0 && (m.dataset.line = b.dataset.line), b.replaceWith(m), --d === 0 && o.remove();
        });
      }
    });
  } };
}, Ge = je, De = (e) => {
  var n;
  const a = (n = I.editorExtensions) == null ? void 0 : n.katex, l = a == null ? void 0 : a.instance, t = R(l);
  return S(() => {
    if (!e.noKatex && !t.value) {
      const r = document.createElement("script");
      r.src = (a == null ? void 0 : a.js) || j.js, r.onload = () => {
        t.value = window.katex;
      }, r.id = `${p}-katex`;
      const i = document.createElement("link");
      i.rel = "stylesheet", i.href = (a == null ? void 0 : a.css) || j.css, i.id = `${p}-katexCss`, _(r, "katex"), _(i);
    }
  }), t;
}, Ve = De, ze = (e, a) => {
  const l = e.renderer.rules.fence.bind(e.renderer.rules);
  e.renderer.rules.fence = (t, n, r, i, c) => {
    const u = t[n], s = u.content.trim();
    if (u.info === "mermaid") {
      let o;
      return t[n].map && t[n].level === 0 && (o = t[n].map[0], t[n].attrSet("data-line", String(o))), `<div class="${p}-mermaid" ${o !== void 0 ? "data-line=" + o : ""} data-mermaid-theme=${a.themeRef.value}>${s}</div>`;
    }
    return l(t, n, r, i, c);
  };
}, We = ze, Q = (e, a) => {
  let l = !0, t = !0;
  const n = e.posMax, r = a > 0 ? e.src.charCodeAt(a - 1) : -1, i = a + 1 <= n ? e.src.charCodeAt(a + 1) : -1;
  return (r === 32 || r === 9 || i >= 48 && i <= 57) && (t = !1), (i === 32 || i === 9) && (l = !1), {
    can_open: l,
    can_close: t
  };
}, Ke = (e, a) => {
  let l, t, n, r;
  if (e.src[e.pos] !== "$")
    return !1;
  if (n = Q(e, e.pos), !n.can_open)
    return a || (e.pending += "$"), e.pos += 1, !0;
  const i = e.pos + 1;
  for (l = i; (l = e.src.indexOf("$", l)) !== -1; ) {
    for (r = l - 1; e.src[r] === "\\"; )
      r -= 1;
    if ((l - r) % 2 == 1)
      break;
    l += 1;
  }
  return l === -1 ? (a || (e.pending += "$"), e.pos = i, !0) : l - i === 0 ? (a || (e.pending += "$$"), e.pos = i + 1, !0) : (n = Q(e, l), n.can_close ? (a || (t = e.push("math_inline", "math", 0), t.markup = "$", t.content = e.src.slice(i, l)), e.pos = l + 1, !0) : (a || (e.pending += "$"), e.pos = i, !0));
}, qe = (e, a, l, t) => {
  let n, r, i, c, u = !1, s = e.bMarks[a] + e.tShift[a], o = e.eMarks[a];
  if (s + 2 > o || e.src.slice(s, s + 2) !== "$$")
    return !1;
  if (s += 2, n = e.src.slice(s, o), t)
    return !0;
  for (n.trim().slice(-2) === "$$" && (n = n.trim().slice(0, -2), u = !0), i = a; !u && (i++, !(i >= l || (s = e.bMarks[i] + e.tShift[i], o = e.eMarks[i], s < o && e.tShift[i] < e.blkIndent))); )
    e.src.slice(s, o).trim().slice(-2) === "$$" && (c = e.src.slice(0, o).lastIndexOf("$$"), r = e.src.slice(s, c), u = !0);
  e.line = i + 1;
  const d = e.push("math_block", "math", 0);
  return d.block = !0, d.content = (n && n.trim() ? n + `
` : "") + e.getLines(a + 1, i, e.tShift[a], !0) + (r && r.trim() ? r : ""), d.map = [a, e.line], d.markup = "$$", !0;
}, Ze = (e, a) => {
  const l = (n) => {
    if (a.katexRef.value) {
      const r = a.katexRef.value.renderToString(n, {
        throwOnError: !1
      });
      return `<span class="${p}-katex-inline" data-processed>${r}</span>`;
    } else
      return `<span class="${p}-katex-inline">${n}</span>`;
  }, t = (n, r) => {
    if (a.katexRef.value) {
      const i = a.katexRef.value.renderToString(n, {
        throwOnError: !1,
        displayMode: !0
      });
      return `<p class="${p}-katex-block" data-line=${r} data-processed>${i}</p>`;
    } else
      return `<p class="${p}-katex-block" data-line=${r}>${n}</p>`;
  };
  e.inline.ruler.after("escape", "math_inline", Ke), e.block.ruler.after("blockquote", "math_block", qe, {
    alt: ["paragraph", "reference", "blockquote", "list"]
  }), e.renderer.rules.math_inline = (n, r) => l(n[r].content), e.renderer.rules.math_block = (n, r) => t(n[r].content, n[r].map[0]) + `
`;
}, Je = Ze, Xe = (e, a) => {
  a = a || {};
  const l = 3, t = a.marker || "!", n = t.charCodeAt(0), r = t.length;
  let i = "", c = "";
  const u = (o, d, b, y, m) => {
    const h = o[d];
    return h.type === "admonition_open" ? (o[d].attrPush([
      "class",
      `${p}-admonition ${p}-admonition-${h.info}`
    ]), o[d].attrSet("data-line", String(o[d].map[0]))) : h.type === "admonition_title_open" && o[d].attrPush(["class", `${p}-admonition-title`]), m.renderToken(o, d, b);
  }, s = (o) => {
    const d = o.trim().split(" ", 2);
    c = "", i = d[0], d.length > 1 && (c = o.substring(i.length + 2)), (c === "" || !c) && (c = i);
  };
  e.block.ruler.before(
    "code",
    "admonition",
    (o, d, b, y) => {
      let m, h, f, w = !1, v = o.bMarks[d] + o.tShift[d], k = o.eMarks[d];
      if (n !== o.src.charCodeAt(v))
        return !1;
      for (m = v + 1; m <= k && t[(m - v) % r] === o.src[m]; m++)
        ;
      const $ = Math.floor((m - v) / r);
      if ($ !== l)
        return !1;
      m -= (m - v) % r;
      const E = o.src.slice(v, m), T = o.src.slice(m, k);
      if (s(T), y)
        return !0;
      for (h = d; h++, !(h >= b || (v = o.bMarks[h] + o.tShift[h], k = o.eMarks[h], v < k && o.sCount[h] < o.blkIndent)); )
        if (n === o.src.charCodeAt(v) && !(o.sCount[h] - o.blkIndent >= 4)) {
          for (m = v + 1; m <= k && t[(m - v) % r] === o.src[m]; m++)
            ;
          if (!(Math.floor((m - v) / r) < $) && (m -= (m - v) % r, m = o.skipSpaces(m), !(m < k))) {
            w = !0;
            break;
          }
        }
      const x = o.parentType, B = o.lineMax;
      return o.parentType = "root", o.lineMax = h, f = o.push("admonition_open", "div", 1), f.markup = E, f.block = !0, f.info = i, f.map = [d, h], f = o.push("admonition_title_open", "p", 1), f.markup = E + " " + i, f.map = [d, h], f = o.push("inline", "", 0), f.content = c, f.map = [d, o.line - 1], f.children = [], f = o.push("admonition_title_close", "p", -1), f.markup = E + " " + i, o.md.block.tokenize(o, d + 1, h), f = o.push("admonition_close", "div", -1), f.markup = o.src.slice(v, m), f.block = !0, o.parentType = x, o.lineMax = B, o.line = h + (w ? 1 : 0), !0;
    },
    {
      alt: ["paragraph", "reference", "blockquote", "list"]
    }
  ), e.renderer.rules.admonition_open = u, e.renderer.rules.admonition_title_open = u, e.renderer.rules.admonition_title_close = u, e.renderer.rules.admonition_close = u;
}, Qe = Xe, Ye = (e, a) => {
  e.renderer.rules.heading_open = (l, t) => {
    var c;
    const n = l[t], r = ((c = l[t + 1].children) == null ? void 0 : c.reduce((u, s) => u + (s.content || ""), "")) || "", i = n.markup.length;
    return a.headsRef.value.push({
      text: r,
      level: i
    }), n.map && n.level === 0 && (n.attrSet("data-line", String(n.map[0])), n.attrSet(
      "id",
      a.mdHeadingId(r, i, a.headsRef.value.length)
    )), e.renderer.renderToken(l, t, a);
  }, e.renderer.rules.heading_close = (l, t, n, r, i) => i.renderToken(l, t, n);
}, et = Ye, tt = (e, a) => {
  const l = e.renderer.rules.fence, t = e.utils.unescapeAll, n = /\[(\w*)(?::([\w ]*))?\]/;
  function r(s) {
    return s.info ? t(s.info).trim() : "";
  }
  function i(s) {
    const o = r(s), [d = null, b = ""] = (n.exec(o) || []).slice(1);
    return [d, b];
  }
  function c(s) {
    const o = r(s);
    return o ? o.split(/(\s+)/g)[0] : "";
  }
  const u = (s, o, d, b, y) => {
    if (s[o].hidden)
      return "";
    const [m, h] = i(s[o]);
    if (m === null)
      return l(s, o, d, b, y);
    let f, w, v, k, $ = "", E = "";
    for (let T = o; T < s.length && (f = s[T], [w, v] = i(f), w === m); T++)
      f.info = f.info.replace(n, ""), f.hidden = !0, k = T - o > 0 ? "" : " checked", $ += `<li><input type="radio" name="label-group-${a.editorId}-${o}"${k}><label for="group-${a.editorId}-${o}-tab-${T - o}" onclick="this.previousElementSibling.click()">${v || c(f)}</label></li>
`, E += `<input type="radio" id="group-${a.editorId}-${o}-tab-${T - o}" name="group-${a.editorId}-${o}"${k}>
` + l(s, T, d, b, y);
    return `<div class="code-tabs">
<ul>
` + $ + `</ul>
` + E + "</div>";
  };
  e.renderer.rules.fence = u;
}, nt = tt, ot = (e) => {
  [
    "paragraph_open",
    "table_open",
    "ordered_list_open",
    "bullet_list_open",
    "blockquote_open",
    "hr",
    "html_block",
    "fence"
  ].forEach((a) => {
    const l = e.renderer.rules[a];
    l ? e.renderer.rules[a] = (t, n, r, i, c) => {
      let u;
      const s = l(t, n, r, i, c);
      return t[n].map && t[n].level === 0 && !/^<!--/.test(s) ? (u = t[n].map[0], s.replace(/^(<[^>]*)/, `$1 data-line="${u}"`)) : s;
    } : e.renderer.rules[a] = (t, n, r, i, c) => {
      let u;
      return t[n].map && t[n].level === 0 && (u = t[n].map[0], t[n].attrSet("data-line", String(u))), c.renderToken(t, n, r);
    };
  });
}, rt = (e, a) => {
  const { editorConfig: l, markdownItConfig: t, markdownItPlugins: n } = I, r = P("editorId"), i = P("showCodeRowNumber"), c = P("theme"), u = U([]), s = Ue(e), o = Ve(e), { reRenderRef: d, replaceMermaid: b } = Ge(e), y = Fe({
    html: !0,
    breaks: !0
  });
  t(y);
  const m = [
    {
      type: "katex",
      plugin: Je,
      options: { katexRef: o }
    },
    {
      type: "image",
      plugin: He,
      options: { figcaption: !0, classes: "md-zoom" }
    },
    {
      type: "admonition",
      plugin: Qe,
      options: {}
    },
    {
      type: "taskList",
      plugin: xe,
      options: {}
    },
    {
      type: "heading",
      plugin: et,
      options: { mdHeadingId: e.mdHeadingId, headsRef: u }
    },
    {
      type: "codeTabs",
      plugin: nt,
      options: { editorId: r }
    }
  ];
  e.noMermaid || m.push({
    type: "mermaid",
    plugin: We,
    options: { themeRef: c }
  }), n(m).forEach(($) => {
    y.use($.plugin, $.options);
  });
  const h = y.options.highlight;
  y.set({
    highlight: ($, E, T) => {
      if (h) {
        const L = h($, E, T);
        if (L)
          return L;
      }
      let x;
      !e.noHighlight && s.value ? s.value.getLanguage(E) ? x = s.value.highlight($, {
        language: E,
        ignoreIllegals: !0
      }).value : x = s.value.highlightAuto($).value : x = y.utils.escapeHtml($);
      const B = i ? ke(x.replace(/^\n+|\n+$/g, "")) : `<span class="code-block">${x.replace(/^\n+|\n+$/g, "")}</span>`;
      return `<pre><code class="language-${E}" language=${E}>${B}</code></pre>`;
    }
  }), ot(y);
  const f = U(e.sanitize(y.render(e.modelValue))), w = () => {
    g.emit(r, M, f.value), e.onHtmlChanged(f.value), e.onGetCatalog(u.value), g.emit(r, W, u.value), b();
  };
  S(w);
  const v = ae(
    async () => {
      u.value = [], f.value = e.sanitize(y.render(e.modelValue)), w();
    },
    (l == null ? void 0 : l.renderDelay) !== void 0 ? l == null ? void 0 : l.renderDelay : a ? 0 : 500
  ), k = H(() => (e.noKatex || o.value) && (e.noHighlight || s.value));
  return C([Y(e, "modelValue"), k, d], v), S(() => {
    g.on(r, {
      name: $e,
      callback() {
        g.emit(r, W, u.value);
      }
    });
  }), { html: f };
}, at = rt, le = {
  modelValue: {
    type: String,
    default: ""
  },
  setting: {
    type: Object,
    default: () => ({})
  },
  onHtmlChanged: {
    type: Function,
    default: () => {
    }
  },
  onGetCatalog: {
    type: Function,
    default: () => {
    }
  },
  mdHeadingId: {
    type: Function,
    default: () => ""
  },
  noMermaid: {
    type: Boolean,
    default: !1
  },
  sanitize: {
    type: Function,
    default: (e) => e
  },
  // 不使用该函数功能
  noKatex: {
    type: Boolean,
    default: !1
  },
  formatCopiedText: {
    type: Function,
    default: (e) => e
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  previewOnly: {
    type: Boolean,
    default: !1
  },
  noImgZoomIn: {
    type: Boolean
  }
}, wt = {
  ...le,
  onChange: {
    type: Function,
    default: () => {
    }
  },
  placeholder: {
    type: String,
    default: ""
  },
  scrollAuto: {
    type: Boolean
  },
  autofocus: {
    type: Boolean
  },
  disabled: {
    type: Boolean
  },
  readonly: {
    type: Boolean
  },
  maxlength: {
    type: Number
  },
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function,
    default: () => {
    }
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function,
    default: () => {
    }
  },
  noPrettier: {
    type: Boolean
  },
  completions: {
    type: Array
  },
  catalogVisible: {
    type: Boolean
  },
  theme: {
    type: String,
    default: "light"
  },
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function,
    default: () => {
    }
  },
  inputBoxWitdh: {
    type: String
  },
  onInputBoxWitdhChange: {
    type: Function
  }
}, lt = /* @__PURE__ */ ee({
  name: "ContentPreview",
  props: le,
  setup(e) {
    const a = P("editorId"), l = P("previewTheme"), t = P("showCodeRowNumber"), {
      html: n
    } = at(e, e.previewOnly);
    return Ne(e, n), Re(e, n), () => A(de, null, [A("div", {
      id: `${a}-preview-wrapper`,
      class: `${p}-preview-wrapper`,
      "data-show": e.setting.preview,
      key: "content-preview-wrapper"
    }, [A("article", {
      id: `${a}-preview`,
      class: [`${p}-preview`, `${l == null ? void 0 : l.value}-theme`, t && `${p}-scrn`],
      innerHTML: n.value
    }, null)]), !e.previewOnly && A("div", {
      id: `${a}-html-wrapper`,
      class: `${p}-preview-wrapper`,
      "data-show": e.setting.htmlPreview,
      key: "html-preview-wrapper"
    }, [A("div", {
      class: `${p}-html`
    }, [n.value])])]);
  }
}), kt = (e, a) => {
  const { editorId: l } = e, t = te({
    // 是否已编译成html
    buildFinished: !1,
    // 存储当前最新的html
    html: ""
  });
  C(
    () => e.modelValue,
    () => {
      t.buildFinished = !1;
    }
  ), S(() => {
    g.on(l, {
      name: M,
      callback(n) {
        t.buildFinished = !0, t.html = n;
      }
    }), g.on(l, {
      name: ne,
      callback() {
        const n = new Promise((r) => {
          if (t.buildFinished)
            r(t.html);
          else {
            const i = (c) => {
              r(c), g.remove(l, M, i);
            };
            g.on(l, {
              name: M,
              callback: i
            });
          }
        });
        e.onSave ? e.onSave(e.modelValue, n) : a.emit("onSave", e.modelValue, n);
      }
    });
  });
}, ie = (e) => {
  var n, r;
  const { editorId: a } = e, l = (r = (n = I) == null ? void 0 : n.editorExtensions) == null ? void 0 : r.highlight;
  F("editorId", a), F(
    "theme",
    H(() => e.theme)
  ), F(
    "language",
    H(() => e.language)
  ), F(
    "highlight",
    H(() => {
      const i = {
        ...G,
        ...l == null ? void 0 : l.css
      }, c = e.codeStyleReverse && e.codeStyleReverseList.includes(e.previewTheme) ? "dark" : e.theme;
      return {
        js: (l == null ? void 0 : l.js) || pe,
        css: i[e.codeTheme] ? i[e.codeTheme][c] : G.atom[c]
      };
    })
  ), F("showCodeRowNumber", e.showCodeRowNumber);
  const t = H(() => {
    var c, u;
    const i = {
      ...D,
      ...(u = (c = I) == null ? void 0 : c.editorConfig) == null ? void 0 : u.languageUserDefined
    };
    return i[e.language] ? i[e.language] : D["zh-CN"];
  });
  F("usedLanguageText", t), F(
    "previewTheme",
    H(() => e.previewTheme)
  ), F(
    "customIcon",
    H(() => e.customIcon)
  );
}, $t = (e) => {
  ie(e), F("tabWidth", e.tabWidth);
}, ce = (e) => {
  S(() => {
    var a, l;
    if (!e.noIconfont)
      if (I.iconfontType === "svg") {
        const t = document.createElement("script");
        t.src = ((a = I.editorExtensions) == null ? void 0 : a.iconfont) || he, t.id = `${p}-icon`, _(t);
      } else {
        const t = document.createElement("link");
        t.rel = "stylesheet", t.href = ((l = I.editorExtensions) == null ? void 0 : l.iconfontClass) || ge, t.id = `${p}-icon-class`, _(t);
      }
  });
}, Ct = (e) => {
  var c, u, s, o, d, b;
  const { noPrettier: a, noUploadImg: l } = e, { editorExtensions: t } = I, n = a || !!((u = (c = I.editorExtensions) == null ? void 0 : c.prettier) != null && u.prettierInstance), r = a || !!((o = (s = I.editorExtensions) == null ? void 0 : s.prettier) != null && o.parserMarkdownInstance), i = l || !!((b = (d = I.editorExtensions) == null ? void 0 : d.cropper) != null && b.instance);
  S(() => {
    var w, v, k, $;
    const y = document.createElement("script"), m = document.createElement("script");
    y.src = ((w = t == null ? void 0 : t.prettier) == null ? void 0 : w.standaloneJs) || V.main, y.id = `${p}-prettier`, m.src = ((v = t == null ? void 0 : t.prettier) == null ? void 0 : v.parserMarkdownJs) || V.markdown, m.id = `${p}-prettierMD`;
    const h = document.createElement("link");
    h.rel = "stylesheet", h.href = ((k = t == null ? void 0 : t.cropper) == null ? void 0 : k.css) || z.css, h.id = `${p}-cropperCss`;
    const f = document.createElement("script");
    f.src = (($ = t == null ? void 0 : t.cropper) == null ? void 0 : $.js) || z.js, f.id = `${p}-cropper`, i || (_(h), _(f)), n || _(y), r || _(m);
  }), ce(e);
}, It = (e, a) => {
  const { editorId: l } = e;
  S(() => {
    g.on(l, {
      name: Ce,
      callback: (t) => {
        e.onError instanceof Function ? e.onError(t) : a.emit("onError", t);
      }
    });
  });
}, St = (e, a) => {
  const { editorId: l } = e, t = te({
    pageFullscreen: e.pageFullscreen,
    fullscreen: !1,
    preview: e.preview,
    htmlPreview: e.preview ? !1 : e.htmlPreview
  }), n = (c, u) => {
    t[c] = u === void 0 ? !t[c] : u, c === "preview" && t.preview ? t.htmlPreview = !1 : c === "htmlPreview" && t.htmlPreview && (t.preview = !1);
  };
  let r = "";
  const i = () => {
    t.pageFullscreen || t.fullscreen ? document.body.style.overflow = "hidden" : document.body.style.overflow = r;
  };
  return C(() => [t.pageFullscreen, t.fullscreen], i), S(() => {
    g.on(l, {
      name: Ie,
      callback(c, u) {
        const s = (o) => {
          g.emit(l, re, "image", {
            desc: "",
            urls: o
          }), u && u();
        };
        e.onUploadImg ? e.onUploadImg(c, s) : a.emit("onUploadImg", c, s);
      }
    }), r = document.body.style.overflow, i();
  }), [t, n];
}, Et = (e) => {
  const { editorId: a } = e, l = U(!1);
  return S(() => {
    g.on(a, {
      name: oe,
      callback: (n) => {
        n === void 0 ? l.value = !l.value : l.value = n;
      }
    });
  }), H(() => !e.toolbarsExclude.includes("catalog") && e.toolbars.includes("catalog") && l.value);
}, Pt = (e, a, l, t, n) => {
  const { editorId: r } = e;
  C(
    () => t.pageFullscreen,
    (c) => {
      g.emit(r, K, c);
    }
  ), C(
    () => t.fullscreen,
    (c) => {
      g.emit(r, q, c);
    }
  ), C(
    () => t.preview,
    (c) => {
      g.emit(r, Z, c);
    }
  ), C(
    () => t.htmlPreview,
    (c) => {
      g.emit(r, J, c);
    }
  ), C(l, (c) => {
    g.emit(r, X, c);
  });
  const i = {
    on(c, u) {
      switch (c) {
        case "pageFullscreen": {
          g.on(r, {
            name: K,
            callback(s) {
              u(s);
            }
          });
          break;
        }
        case "fullscreen": {
          g.on(r, {
            name: q,
            callback(s) {
              u(s);
            }
          });
          break;
        }
        case "preview": {
          g.on(r, {
            name: Z,
            callback(s) {
              u(s);
            }
          });
          break;
        }
        case "htmlPreview": {
          g.on(r, {
            name: J,
            callback(s) {
              u(s);
            }
          });
          break;
        }
        case "catalog": {
          g.on(r, {
            name: X,
            callback(s) {
              u(s);
            }
          });
          break;
        }
      }
    },
    togglePageFullscreen(c) {
      n("pageFullscreen", c);
    },
    toggleFullscreen(c) {
      g.emit(r, Se, c);
    },
    togglePreview(c) {
      n("preview", c);
    },
    toggleHtmlPreview(c) {
      n("htmlPreview", c);
    },
    toggleCatalog(c) {
      g.emit(r, oe, c);
    },
    triggerSave() {
      g.emit(r, ne);
    },
    insert(c) {
      g.emit(r, re, "universal", { generate: c });
    },
    focus(c) {
      g.emit(r, Ee, c);
    }
  };
  a.expose(i);
}, it = (e) => e, se = {
  /**
   * markdown content.
   *
   * @default ''
   */
  modelValue: {
    type: String,
    default: ""
  },
  /**
   * 主题，支持light和dark
   *
   * @default 'light'
   */
  theme: {
    type: String,
    default: "light"
  },
  /**
   * 外层类名
   *
   * @default ''
   */
  class: {
    type: String,
    default: ""
  },
  /**
   * 预设语言名称
   *
   * @default 'zh-CN'
   */
  language: {
    type: String,
    default: "zh-CN"
  },
  /**
   * html变化事件
   */
  onHtmlChanged: {
    type: Function
  },
  /**
   * 获取目录结构
   */
  onGetCatalog: {
    type: Function
  },
  /**
   * 编辑器唯一标识
   *
   * @default 'md-editor-v3'
   */
  editorId: {
    type: String,
    default: ye
  },
  /**
   * 预览中代码是否显示行号
   *
   * @default false
   */
  showCodeRowNumber: {
    type: Boolean,
    default: !1
  },
  /**
   * 预览内容样式
   *
   * @default 'default'
   */
  previewTheme: {
    type: String,
    default: "default"
  },
  /**
   * 编辑器样式
   */
  style: {
    type: Object,
    default: () => ({})
  },
  /**
   * 标题的id生成方式
   *
   * @default (text: string) => text
   */
  mdHeadingId: {
    type: Function,
    default: it
  },
  /**
   *
   * 不能保证文本正确的情况，在marked编译md文本后通过该方法处理
   * 推荐DOMPurify、sanitize-html
   *
   * @default (text: string) => text
   */
  sanitize: {
    type: Function,
    default: (e) => e
  },
  /**
   * 不使用该mermaid
   *
   * @default false
   */
  noMermaid: {
    type: Boolean,
    default: !1
  },
  /**
   * 不使用katex
   *
   * @default false
   */
  noKatex: {
    type: Boolean,
    default: !1
  },
  /**
   * 代码主题
   *
   * @default 'atom'
   */
  codeTheme: {
    type: String,
    default: "atom"
  },
  /**
   * 不插入iconfont链接
   *
   * @default false
   */
  noIconfont: {
    type: Boolean
  },
  /**
   * 复制代码格式化方法
   *
   * @default (text) => text
   */
  formatCopiedText: {
    type: Function,
    default: (e) => e
  },
  /**
   * 某些预览主题的代码模块背景是暗色系
   * 将这个属性设置为true，会自动在该主题下的light模式下使用暗色系的代码风格
   *
   * @default true
   */
  codeStyleReverse: {
    type: Boolean,
    default: !0
  },
  /**
   * 需要自动调整的预览主题
   *
   * @default ['default', 'mk-cute']
   */
  codeStyleReverseList: {
    type: Array,
    default: ["default", "mk-cute"]
  },
  noHighlight: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否关闭编辑器默认的放大缩小功能
   */
  noImgZoomIn: {
    type: Boolean,
    default: !1
  },
  /**
   * 自定义的图标
   */
  customIcon: {
    type: Object,
    default: {}
  }
}, Tt = {
  ...se,
  /**
   * input回调事件
   */
  onChange: {
    type: Function
  },
  /**
   * input回调事件
   */
  onSave: {
    type: Function
  },
  /**
   * 上传图片事件
   */
  onUploadImg: {
    type: Function
  },
  /**
   * 是否页面内全屏
   *
   * @default false
   */
  pageFullscreen: {
    type: Boolean,
    default: !1
  },
  /**
   * 是否展开预览
   *
   * @default true
   */
  preview: {
    type: Boolean,
    default: !0
  },
  /**
   * 是否展开html预览
   *
   * @default false
   */
  htmlPreview: {
    type: Boolean,
    default: !1
  },
  /**
   * 仅预览模式，不显示toolbar和编辑框
   *
   * @4.0.0开始移除该设置，使用组件MdPreview替换
   *
   * @default false
   */
  // previewOnly: {
  //   type: Boolean as PropType<boolean>,
  //   default: false
  // },
  /**
   * 工具栏选择显示
   *
   * @default allToolbar
   */
  toolbars: {
    type: Array,
    default: ve
  },
  /**
   * 工具栏选择不显示
   *
   * @default []
   */
  toolbarsExclude: {
    type: Array,
    default: []
  },
  /**
   * 格式化md
   *
   * @default true
   */
  noPrettier: {
    type: Boolean,
    default: !1
  },
  /**
   * 一个tab等于空格数
   *
   * @default 2
   */
  tabWidth: {
    type: Number,
    default: 2
  },
  /**
   * 表格预设格子数
   *
   * @default [6, 4]
   */
  tableShape: {
    type: Array,
    default: () => [6, 4]
  },
  /**
   * 空提示
   *
   * @default ''
   */
  placeholder: {
    type: String,
    default: ""
  },
  /**
   * 自定义的工具栏列表
   */
  defToolbars: {
    type: [String, Object]
  },
  /**
   * 内部错误捕获
   */
  onError: {
    type: Function
  },
  /**
   * 页脚列表显示顺序
   */
  footers: {
    type: Array,
    default: be
  },
  /**
   * 是否默认激活输入框和预览框同步滚动
   *
   * @default true
   */
  scrollAuto: {
    type: Boolean,
    default: !0
  },
  /**
   * 自定义的也叫工具组件列表
   */
  defFooters: {
    type: [String, Object]
  },
  /**
   * 是否禁用上传图片
   *
   * @default false
   */
  noUploadImg: {
    type: Boolean
  },
  /**
   * 文本区域自动获得焦点
   *
   * @default false
   */
  autoFocus: {
    type: Boolean
  },
  /**
   * 禁用文本区域
   *
   * @default false
   */
  disabled: {
    type: Boolean
  },
  /**
   * 文本区域为只读
   *
   * @default false
   */
  readOnly: {
    type: Boolean
  },
  /**
   * 文本区域允许的最大字符数
   */
  maxLength: {
    type: Number
  },
  /**
   * 是否启用自动识别粘贴代码类别
   * 目前支持 vscode 复制的代码识别
   *
   * @default false
   */
  autoDetectCode: {
    type: Boolean
  },
  /**
   * 输入框失去焦点时触发事件
   */
  onBlur: {
    type: Function
  },
  /**
   * 输入框获得焦点时触发事件
   */
  onFocus: {
    type: Function
  },
  /**
   * @codemirror/autocomplete匹配关键词的方法列表
   *
   * 它会被像下面这样嵌入编辑器
   *
   * import { autocompletion } from '@codemirror/autocomplete';
   * autocompletion({
   *   override: [...completions]
   * })
   */
  completions: {
    type: Array
  },
  /**
   * 是否在工具栏下面显示对应的文字名称
   *
   * @default false
   */
  showToolbarName: {
    type: Boolean,
    default: !1
  },
  /**
   * 字符输入事件
   */
  onInput: {
    type: Function
  },
  onDrop: {
    type: Function
  },
  /**
   * 输入框的默认宽度
   *
   * @example '100px'/'50%'
   * @default '50%
   */
  inputBoxWitdh: {
    type: String,
    default: "50%"
  },
  /**
   * 输入框宽度变化事件
   */
  onInputBoxWitdhChange: {
    type: Function
  }
}, ue = ["onHtmlChanged", "onGetCatalog"], _t = [
  ...ue,
  "onChange",
  "onSave",
  "onUploadImg",
  "onError",
  "update:modelValue",
  "onBlur",
  "onFocus",
  "onInput",
  "onDrop",
  "onInputBoxWitdhChange"
], ct = /* @__PURE__ */ ee({
  name: "MdPreview",
  props: se,
  emits: ue,
  setup(e, a) {
    const {
      editorId: l,
      noKatex: t,
      noMermaid: n,
      noHighlight: r
    } = e;
    return ie(e), ce(e), me(() => {
      g.clear(l);
    }), () => A("div", {
      id: l,
      class: [p, e.class, e.theme === "dark" && `${p}-dark`, `${p}-previewOnly`],
      style: e.style
    }, [A(lt, {
      modelValue: e.modelValue,
      onHtmlChanged: (i) => {
        e.onHtmlChanged ? e.onHtmlChanged(i) : a.emit("onHtmlChanged", i);
      },
      onGetCatalog: (i) => {
        e.onGetCatalog ? e.onGetCatalog(i) : a.emit("onGetCatalog", i);
      },
      mdHeadingId: e.mdHeadingId,
      noMermaid: n,
      sanitize: e.sanitize,
      noKatex: t,
      formatCopiedText: e.formatCopiedText,
      noHighlight: r,
      noImgZoomIn: e.noImgZoomIn,
      previewOnly: !0
    }, null)]);
  }
}), N = ct;
N.install = (e) => (e.component(N.name, N), e);
export {
  lt as C,
  N as M,
  _t as a,
  $t as b,
  wt as c,
  Ct as d,
  Tt as e,
  It as f,
  St as g,
  Et as h,
  Pt as i,
  kt as u
};

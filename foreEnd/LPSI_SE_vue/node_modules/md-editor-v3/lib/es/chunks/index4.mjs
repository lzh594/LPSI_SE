var r = Object.defineProperty;
var p = (o, s, t) => s in o ? r(o, s, { enumerable: !0, configurable: !0, writable: !0, value: t }) : o[s] = t;
var i = (o, s, t) => (p(o, typeof s != "symbol" ? s + "" : s, t), t);
class h {
  constructor() {
    // 事件池
    i(this, "pools", {});
  }
  // 移除事件监听
  remove(s, t, n) {
    const a = this.pools[s] && this.pools[s][t];
    a && (this.pools[s][t] = a.filter((e) => e !== n));
  }
  // 清空全部事件，由于单一实例，多次注册会被共享内容
  clear(s) {
    this.pools[s] = {};
  }
  // 注册事件监听
  on(s, t) {
    return this.pools[s] || (this.pools[s] = {}), this.pools[s][t.name] || (this.pools[s][t.name] = []), this.pools[s][t.name].push(t.callback), this.pools[s][t.name].includes(t.callback);
  }
  // 触发事件
  emit(s, t, ...n) {
    this.pools[s] || (this.pools[s] = {});
    const a = this.pools[s][t];
    a && a.forEach((e) => {
      try {
        e(...n);
      } catch (c) {
        console.error(`${t} monitor event exception！`, c);
      }
    });
  }
}
const C = new h(), E = "onSave", g = "changeCatalogVisible", A = "changeFullscreen", R = "pageFullscreenChanged", _ = "fullscreenChanged", d = "previewChanged", L = "htmlPreviewChanged", N = "catalogVisibleChanged", f = "textareaFocus", S = "buildFinished", b = "errorCatcher", G = "replace", H = "uploadImage", T = "openModals", F = "ctrlZ", m = "ctrlShiftZ", I = "catalogChanged", D = "pushCatalog", O = (o, s = "image.png") => {
  const t = o.split(","), n = t[0].match(/:(.*?);/);
  if (n) {
    const l = n[1], a = atob(t[1]);
    let e = a.length;
    const c = new Uint8Array(e);
    for (; e--; )
      c[e] = a.charCodeAt(e);
    return new File([c], s, { type: l });
  }
  return null;
}, w = (o) => {
  if (!o)
    return o;
  const s = o.split(`
`), t = ['<span rn-wrapper aria-hidden="true">'];
  return s.forEach(() => {
    t.push("<span></span>");
  }), t.push("</span>"), `<span class="code-block">${o}</span>${t.join("")}`;
}, P = (o, s) => {
  if (!o || !s)
    return 0;
  const t = o == null ? void 0 : o.getBoundingClientRect();
  if (s === document.documentElement)
    return t.top - s.clientTop;
  const n = s == null ? void 0 : s.getBoundingClientRect();
  return t.top - n.top;
}, U = () => `${Date.now().toString(36)}${Math.random().toString(36).substring(2)}`;
export {
  S as B,
  I as C,
  b as E,
  _ as F,
  L as H,
  E as O,
  D as P,
  G as R,
  f as T,
  H as U,
  w as a,
  C as b,
  g as c,
  R as d,
  d as e,
  N as f,
  P as g,
  A as h,
  O as i,
  T as j,
  m as k,
  F as l,
  U as u
};
